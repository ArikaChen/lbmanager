From a4d79d45a07b1780ac59e481a6e0795e16c9c34f Mon Sep 17 00:00:00 2001
From: ArikaChen <eaglesora@gmail.com>
Date: Wed, 15 Mar 2017 09:45:22 +0800
Subject: [PATCH] lvs: add fullnat and synproxy support

Signed-off-by: ArikaChen <eaglesora@gmail.com>
---
 keepalived/Makefile.in                   |   6 +
 keepalived/check/check_data.c            |  92 +++++++-
 keepalived/check/check_http.c            |  22 +-
 keepalived/check/check_misc.c            |   6 +-
 keepalived/check/check_parser.c          |  37 +++
 keepalived/check/check_smtp.c            |   6 +-
 keepalived/check/check_ssl.c             |   2 +-
 keepalived/check/check_tcp.c             |   4 +-
 keepalived/check/ipvswrapper.c           | 305 +++++++++++++++++++++++-
 keepalived/check/ipwrapper.c             | 383 ++++++++++++++++++++++++++++++-
 keepalived/include/check_data.h          |  24 +-
 keepalived/include/ipvswrapper.h         |   2 +
 keepalived/include/ipwrapper.h           |   4 +-
 keepalived/libipvs-2.6/ip_vs.h           |  97 +++++++-
 keepalived/libipvs-2.6/ip_vs_nl_policy.c |  14 +-
 keepalived/libipvs-2.6/libipvs.c         | 328 +++++++++++++++++++++++++-
 keepalived/libipvs-2.6/libipvs.h         |  39 ++++
 17 files changed, 1331 insertions(+), 40 deletions(-)

diff --git a/keepalived/Makefile.in b/keepalived/Makefile.in
index cabcc5f..08f34cd 100644
--- a/keepalived/Makefile.in
+++ b/keepalived/Makefile.in
@@ -19,6 +19,8 @@ mandir      = @mandir@
 init_dir    = $(sysconfdir)/rc.d/init.d
 conf_dir    = $(sysconfdir)/keepalived
 sysconf_dir = $(sysconfdir)/sysconfig
+libdir      = @libdir@
+includedir  = @includedir@
 
 CC = @CC@
 STRIP = @STRIP@
@@ -107,3 +109,7 @@ install:
 	install -d $(DESTDIR)$(mandir)/man8
 	install -m 644 ../doc/man/man5/keepalived.conf.5 $(DESTDIR)$(mandir)/man5
 	install -m 644 ../doc/man/man8/keepalived.8 $(DESTDIR)$(mandir)/man8
+	install -d $(DESTDIR)$(libdir)
+	install -d $(DESTDIR)$(includedir)/ipvs
+	install -m 644 libipvs-2.6/*.a $(DESTDIR)$(libdir)/
+	install -m 644 libipvs-2.6/*.h $(DESTDIR)$(includedir)/ipvs/
diff --git a/keepalived/check/check_data.c b/keepalived/check/check_data.c
index 68412ab..9ac3c1e 100644
--- a/keepalived/check/check_data.c
+++ b/keepalived/check/check_data.c
@@ -69,6 +69,76 @@ dump_ssl(void)
 		log_message(LOG_INFO, " Using autogen SSL context");
 }
 
+/* local IP address group facility functions */
+static void
+free_laddr_group(void *data)
+{
+	local_addr_group *laddr_group = data;
+	FREE_PTR(laddr_group->gname);
+	free_list(laddr_group->addr_ip);
+	free_list(laddr_group->range);
+	FREE(laddr_group);
+}
+static void
+dump_laddr_group(void *data)
+{
+	local_addr_group *laddr_group = data;
+
+	log_message(LOG_INFO, " local IP address group = %s", laddr_group->gname);
+	dump_list(laddr_group->addr_ip);
+	dump_list(laddr_group->range);
+}
+static void
+free_laddr_entry(void *data)
+{
+	FREE(data);
+}
+static void
+dump_laddr_entry(void *data)
+{
+	local_addr_entry *laddr_entry = data;
+
+	if (laddr_entry->range)
+		log_message(LOG_INFO, "   IP Range = %s-%d"
+				    , inet_sockaddrtos(&laddr_entry->addr)
+				    , laddr_entry->range);
+	else
+		log_message(LOG_INFO, "   IP = %s"
+				    , inet_sockaddrtos(&laddr_entry->addr));
+}
+void
+alloc_laddr_group(char *gname)
+{
+	int size = strlen(gname);
+	local_addr_group *new;
+
+	new = (local_addr_group *) MALLOC(sizeof (local_addr_group));
+	new->gname = (char *) MALLOC(size + 1);
+	memcpy(new->gname, gname, size);
+	new->addr_ip = alloc_list(free_laddr_entry, dump_laddr_entry);
+	new->range = alloc_list(free_laddr_entry, dump_laddr_entry);
+
+	list_add(check_data->laddr_group, new);
+}
+void
+alloc_laddr_entry(vector_t *strvec)
+{
+	local_addr_group *laddr_group = LIST_TAIL_DATA(check_data->laddr_group);
+	local_addr_entry *new;
+
+	new = (local_addr_entry *) MALLOC(sizeof (local_addr_entry));
+
+
+	new->range = inet_stor(vector_slot(strvec, 0));
+	inet_stosockaddr(vector_slot(strvec, 0), NULL, &new->addr);
+	if (!new->range)
+		list_add(laddr_group->addr_ip, new);
+	else if ( (0 < new->range) && (new->range < 255) )
+		list_add(laddr_group->range, new);
+	else
+		log_message(LOG_INFO, "invalid: local IP address range %d", new->range);
+}
+
 /* Virtual server group facility functions */
 static void
 free_vsg(void *data)
@@ -143,8 +213,10 @@ alloc_vsg_entry(vector_t *strvec)
 		inet_stosockaddr(vector_slot(strvec, 0), vector_slot(strvec, 1), &new->addr);
 		if (!new->range)
 			list_add(vsg->addr_ip, new);
-		else
+		else if ((0 < new->range) && (new->range < 255))
 			list_add(vsg->range, new);
+		else
+			log_message(LOG_INFO, "invalid: VSG IP address range %d", new->range);
 	}
 }
 
@@ -159,6 +231,8 @@ free_vs(void *data)
 	free_list(vs->rs);
 	FREE_PTR(vs->quorum_up);
 	FREE_PTR(vs->quorum_down);
+	FREE_PTR(vs->local_addr_gname);
+	FREE_PTR(vs->vip_bind_dev);
 	FREE(vs);
 }
 static void
@@ -189,6 +263,8 @@ dump_vs(void *data)
 	       (vs->service_type == IPPROTO_TCP) ? "TCP" : "UDP");
 	log_message(LOG_INFO, "   alpha is %s, omega is %s",
 		    vs->alpha ? "ON" : "OFF", vs->omega ? "ON" : "OFF");
+	log_message(LOG_INFO, "   SYN proxy is %s", 
+		    vs->syn_proxy ? "ON" : "OFF");
 	log_message(LOG_INFO, "   quorum = %lu, hysteresis = %lu", vs->quorum, vs->hysteresis);
 	if (vs->quorum_up)
 		log_message(LOG_INFO, "   -> Notify script UP = %s",
@@ -210,6 +286,9 @@ dump_vs(void *data)
 	case IP_VS_CONN_F_TUNNEL:
 		log_message(LOG_INFO, "   lb_kind = TUN");
 		break;
+	case IP_VS_CONN_F_FULLNAT:
+		log_message(LOG_INFO, "   lb_kind = FNAT");
+		break;
 #endif
 	}
 
@@ -219,6 +298,10 @@ dump_vs(void *data)
 	}
 	if (!LIST_ISEMPTY(vs->rs))
 		dump_list(vs->rs);
+	if (vs->local_addr_gname)
+		log_message(LOG_INFO, " LOCAL_ADDR GROUP = %s", vs->local_addr_gname);
+	if (vs->vip_bind_dev)
+		log_message(LOG_INFO, " vip_bind_dev = %s", vs->vip_bind_dev);
 }
 
 void
@@ -243,11 +326,14 @@ alloc_vs(char *ip, char *port)
 	new->virtualhost = NULL;
 	new->alpha = 0;
 	new->omega = 0;
+	new->syn_proxy = 0;
 	new->quorum_up = NULL;
 	new->quorum_down = NULL;
 	new->quorum = 1;
 	new->hysteresis = 0;
 	new->quorum_state = UP;
+	new->local_addr_gname = NULL;
+	new->vip_bind_dev = NULL;
 
 	list_add(check_data->vs, new);
 }
@@ -326,6 +412,7 @@ alloc_check_data(void)
 	new = (check_data_t *) MALLOC(sizeof(check_data_t));
 	new->vs = alloc_list(free_vs, dump_vs);
 	new->vs_group = alloc_list(free_vsg, dump_vsg);
+	new->laddr_group = alloc_list(free_laddr_group, dump_laddr_group);
 
 	return new;
 }
@@ -335,6 +422,7 @@ free_check_data(check_data_t *data)
 {
 	free_list(data->vs);
 	free_list(data->vs_group);
+	free_list(data->laddr_group);
 	FREE(data);
 }
 
@@ -349,6 +437,8 @@ dump_check_data(check_data_t *data)
 		log_message(LOG_INFO, "------< LVS Topology >------");
 		log_message(LOG_INFO, " System is compiled with LVS v%d.%d.%d",
 		       NVERSION(IP_VS_VERSION_CODE));
+		if (!LIST_ISEMPTY(data->laddr_group))
+			dump_list(data->laddr_group);
 		if (!LIST_ISEMPTY(data->vs_group))
 			dump_list(data->vs_group);
 		dump_list(data->vs);
diff --git a/keepalived/check/check_http.c b/keepalived/check/check_http.c
index 18431f9..8c44c4b 100644
--- a/keepalived/check/check_http.c
+++ b/keepalived/check/check_http.c
@@ -256,7 +256,7 @@ epilog(thread_t * thread, int method, int t, int c)
 	 * servers.
 	 */
 	if (http->retry_it > http_get_check->nb_get_retry-1) {
-		if (svr_checker_up(checker->id, checker->rs)) {
+		if (svr_checker_up(DOWN, checker->id, checker->rs)) {
 			log_message(LOG_INFO, "Check on service %s failed after %d retry."
 			       , FMT_HTTP_RS(checker));
 			smtp_alert(checker->rs, NULL, NULL,
@@ -316,7 +316,7 @@ timeout_epilog(thread_t * thread, char *smtp_msg, char *debug_msg)
 			    , FMT_HTTP_RS(checker));
 
 	/* check if server is currently alive */
-	if (svr_checker_up(checker->id, checker->rs)) {
+	if (svr_checker_up(DOWN, checker->id, checker->rs)) {
 		smtp_alert(checker->rs, NULL, NULL,
 			   "DOWN", smtp_msg);
 		update_svr_checker_state(DOWN, checker->id
@@ -364,7 +364,7 @@ http_handle_response(thread_t * thread, unsigned char digest[16]
 	if (fetched_url->status_code) {
 		if (req->status_code != fetched_url->status_code) {
 			/* check if server is currently alive */
-			if (svr_checker_up(checker->id, checker->rs)) {
+			if (svr_checker_up(DOWN, checker->id, checker->rs)) {
 				log_message(LOG_INFO,
 				       "HTTP status code error to %s url(%s)"
 				       ", status_code [%d].",
@@ -406,7 +406,7 @@ http_handle_response(thread_t * thread, unsigned char digest[16]
 
 		if (r) {
 			/* check if server is currently alive */
-			if (svr_checker_up(checker->id, checker->rs)) {
+			if (svr_checker_up(DOWN, checker->id, checker->rs)) {
 				log_message(LOG_INFO,
 				       "MD5 digest error to %s url[%s]"
 				       ", MD5SUM [%s].",
@@ -439,7 +439,7 @@ http_handle_response(thread_t * thread, unsigned char digest[16]
 		}
 	}
 
-	if (!svr_checker_up(checker->id, checker->rs)) {
+	if (!svr_checker_up(UP, checker->id, checker->rs)) {
 		switch (last_success) {
 			case none:
 				break;
@@ -450,7 +450,7 @@ http_handle_response(thread_t * thread, unsigned char digest[16]
 				       , http->url_it + 1);
 				return epilog(thread, 1, 1, 0) + 1;
 			case on_digest:
-				if (!svr_checker_up(checker->id, checker->rs))
+				if (!svr_checker_up(UP, checker->id, checker->rs))
 					log_message(LOG_INFO, "MD5 digest success to %s url(%d)."
 						   , FMT_HTTP_RS(checker)
 						   , http->url_it + 1);
@@ -533,7 +533,7 @@ http_read_thread(thread_t * thread)
 
 		if (r == -1) {
 			/* We have encourred a real read error */
-			if (svr_checker_up(checker->id, checker->rs)) {
+			if (svr_checker_up(DOWN, checker->id, checker->rs)) {
 				log_message(LOG_INFO, "Read error with server %s: %s"
 				       , FMT_HTTP_RS(checker)
 				       , strerror(errno));
@@ -683,7 +683,7 @@ http_request_thread(thread_t * thread)
 				    , FMT_HTTP_RS(checker));
 
 		/* check if server is currently alive */
-		if (svr_checker_up(checker->id, checker->rs)) {
+		if (svr_checker_up(DOWN, checker->id, checker->rs)) {
 			smtp_alert(checker->rs, NULL, NULL,
 				   "DOWN",
 				   "=> CHECK failed on service"
@@ -721,7 +721,7 @@ http_check_thread(thread_t * thread)
 	switch (status) {
 	case connect_error:
 		/* check if server is currently alive */
-		if (svr_checker_up(checker->id, checker->rs)) {
+		if (svr_checker_up(DOWN, checker->id, checker->rs)) {
 			log_message(LOG_INFO, "Error connecting server %s."
 					 , FMT_HTTP_RS(checker));
 			smtp_alert(checker->rs, NULL, NULL,
@@ -802,7 +802,7 @@ http_check_thread(thread_t * thread)
 						     (req->ssl, ret));
 #endif
 				if ((http_get_check->proto == PROTO_SSL) &&
-				    (svr_checker_up(checker->id, checker->rs))) {
+				    (svr_checker_up(DOWN, checker->id, checker->rs))) {
 					log_message(LOG_INFO, "SSL handshake/communication error"
 							 " connecting to server"
 							 " (openssl errno: %d) %s."
@@ -855,7 +855,7 @@ http_connect_thread(thread_t * thread)
 		 * Check completed.
 		 * check if server is currently alive.
 		 */
-		if (!svr_checker_up(checker->id, checker->rs)) {
+		if (!svr_checker_up(UP, checker->id, checker->rs)) {
 			log_message(LOG_INFO, "Remote Web server %s succeed on service."
 					    , FMT_HTTP_RS(checker));
 			smtp_alert(checker->rs, NULL, NULL, "UP",
diff --git a/keepalived/check/check_misc.c b/keepalived/check/check_misc.c
index 53e08e9..b618210 100644
--- a/keepalived/check/check_misc.c
+++ b/keepalived/check/check_misc.c
@@ -189,7 +189,7 @@ misc_check_child_thread(thread_t * thread)
 		pid = THREAD_CHILD_PID(thread);
 
 		/* The child hasn't responded. Kill it off. */
-		if (svr_checker_up(checker->id, checker->rs)) {
+		if (svr_checker_up(DOWN, checker->id, checker->rs)) {
 			log_message(LOG_INFO, "Misc check to [%s] for [%s] timed out"
 					    , inet_sockaddrtos(&checker->rs->addr)
 					    , misck_checker->path);
@@ -223,7 +223,7 @@ misc_check_child_thread(thread_t * thread)
 				update_svr_wgt(status - 2, checker->vs, checker->rs);
 
 			/* everything is good */
-			if (!svr_checker_up(checker->id, checker->rs)) {
+			if (!svr_checker_up(UP, checker->id, checker->rs)) {
 				log_message(LOG_INFO, "Misc check to [%s] for [%s] success."
 						    , inet_sockaddrtos(&checker->rs->addr)
 						    , misck_checker->path);
@@ -235,7 +235,7 @@ misc_check_child_thread(thread_t * thread)
 							   , checker->rs);
 			}
 		} else {
-			if (svr_checker_up(checker->id, checker->rs)) {
+			if (svr_checker_up(DOWN, checker->id, checker->rs)) {
 				log_message(LOG_INFO, "Misc check to [%s] for [%s] failed."
 						    , inet_sockaddrtos(&checker->rs->addr)
 						    , misck_checker->path);
diff --git a/keepalived/check/check_parser.c b/keepalived/check/check_parser.c
index cc270ab..8936dee 100644
--- a/keepalived/check/check_parser.c
+++ b/keepalived/check/check_parser.c
@@ -68,6 +68,14 @@ vsg_handler(vector_t *strvec)
 	alloc_vsg(vector_slot(strvec, 1));
 	alloc_value_block(strvec, alloc_vsg_entry);
 }
+
+static void
+laddr_group_handler(vector_t *strvec)
+{
+	alloc_laddr_group(vector_slot(strvec, 1));
+	alloc_value_block(strvec, alloc_laddr_entry);
+}
+
 static void
 vs_handler(vector_t *strvec)
 {
@@ -106,6 +114,8 @@ lbkind_handler(vector_t *strvec)
 		vs->loadbalancing_kind = IP_VS_CONN_F_DROUTE;
 	else if (!strcmp(str, "TUN"))
 		vs->loadbalancing_kind = IP_VS_CONN_F_TUNNEL;
+	else if (!strcmp(str, "FNAT"))
+		vs->loadbalancing_kind = IP_VS_CONN_F_FULLNAT;
 	else
 		log_message(LOG_INFO, "PARSER : unknown [%s] routing method.", str);
 }
@@ -283,6 +293,26 @@ hysteresis_handler(vector_t *strvec)
 	vs->hysteresis = tmp;
 }
 
+static void 
+laddr_gname_handler(vector_t *strvec)
+{
+	virtual_server_t *vs = LIST_TAIL_DATA(check_data->vs);
+	
+	vs->local_addr_gname = set_value(strvec);
+}
+static void 
+syn_proxy_handler(vector_t *strvec)
+{
+	virtual_server_t *vs = LIST_TAIL_DATA(check_data->vs);
+	vs->syn_proxy = 1;
+}
+static void
+bind_dev_handler(vector_t *strvec)
+{
+	virtual_server_t *vs = LIST_TAIL_DATA(check_data->vs);
+	vs->vip_bind_dev = set_value(strvec);
+}
+
 vector_t *
 check_init_keywords(void)
 {
@@ -296,6 +326,9 @@ check_init_keywords(void)
 	install_keyword("certificate", &sslcert_handler);
 	install_keyword("key", &sslkey_handler);
 
+	/* local IP address mapping */
+	install_keyword_root("local_address_group", &laddr_group_handler);
+
 	/* Virtual server mapping */
 	install_keyword_root("virtual_server_group", &vsg_handler);
 	install_keyword_root("virtual_server", &vs_handler);
@@ -338,5 +371,9 @@ check_init_keywords(void)
 	install_checkers_keyword();
 	install_sublevel_end();
 
+	install_keyword("laddr_group_name", &laddr_gname_handler);
+	install_keyword("syn_proxy", &syn_proxy_handler);
+	install_keyword("vip_bind_dev", &bind_dev_handler);
+
 	return keywords;
 }
diff --git a/keepalived/check/check_smtp.c b/keepalived/check/check_smtp.c
index a52b755..e8423dc 100644
--- a/keepalived/check/check_smtp.c
+++ b/keepalived/check/check_smtp.c
@@ -263,7 +263,7 @@ smtp_final(thread_t *thread, int error, const char *format, ...)
 	
 	if (error) {
 		/* Always syslog the error when the real server is up */
-                if (svr_checker_up(checker->id, checker->rs)) {
+                if (svr_checker_up(DOWN, checker->id, checker->rs)) {
 			if (format != NULL) {
 				memcpy(error_buff, "SMTP_CHECK ", 11);
 				va_start(varg_list, format);
@@ -294,7 +294,7 @@ smtp_final(thread_t *thread, int error, const char *format, ...)
 		 * be noted that smtp_alert makes a copy of the string arguments, so
 		 * we don't have to keep them statically allocated.
 		 */
-                if (svr_checker_up(checker->id, checker->rs)) {
+                if (svr_checker_up(DOWN, checker->id, checker->rs)) {
 			if (format != NULL) {
 				snprintf(smtp_buff, 542, "=> CHECK failed on service : %s <=",
 					 error_buff + 11);
@@ -754,7 +754,7 @@ smtp_connect_thread(thread_t *thread)
 	 * will be reset and we will continue on checking them one by one.
 	 */
 	if ((smtp_checker->host_ptr = list_element(smtp_checker->host, smtp_checker->host_ctr)) == NULL) {
-		if (!svr_checker_up(checker->id, checker->rs)) {
+		if (!svr_checker_up(UP, checker->id, checker->rs)) {
 			log_message(LOG_INFO, "Remote SMTP server %s succeed on service."
 					    , FMT_CHK(checker));
 
diff --git a/keepalived/check/check_ssl.c b/keepalived/check/check_ssl.c
index aa19011..b37d09e 100644
--- a/keepalived/check/check_ssl.c
+++ b/keepalived/check/check_ssl.c
@@ -291,7 +291,7 @@ ssl_read_thread(thread_t * thread)
 
 		if (r && !req->extracted) {
 			/* check if server is currently alive */
-			if (svr_checker_up(checker->id, checker->rs)) {
+			if (svr_checker_up(DOWN, checker->id, checker->rs)) {
 				smtp_alert(checker->rs, NULL, NULL,
 					   "DOWN",
 					   "=> SSL CHECK failed on service"
diff --git a/keepalived/check/check_tcp.c b/keepalived/check/check_tcp.c
index b941ab2..02b566e 100644
--- a/keepalived/check/check_tcp.c
+++ b/keepalived/check/check_tcp.c
@@ -80,7 +80,7 @@ tcp_check_thread(thread_t * thread)
 	if (status == connect_success) {
 		close(thread->u.fd);
 
-		if (!svr_checker_up(checker->id, checker->rs)) {
+		if (!svr_checker_up(UP, checker->id, checker->rs)) {
 			log_message(LOG_INFO, "TCP connection to %s success."
 					, FMT_TCP_RS(checker));
 			smtp_alert(checker->rs, NULL, NULL,
@@ -93,7 +93,7 @@ tcp_check_thread(thread_t * thread)
 
 	} else {
 
-		if (svr_checker_up(checker->id, checker->rs)) {
+		if (svr_checker_up(DOWN, checker->id, checker->rs)) {
 			log_message(LOG_INFO, "TCP connection to %s failed !!!"
 					, FMT_TCP_RS(checker));
 			smtp_alert(checker->rs, NULL, NULL,
diff --git a/keepalived/check/ipvswrapper.c b/keepalived/check/ipvswrapper.c
index b2441cf..ea23834 100644
--- a/keepalived/check/ipvswrapper.c
+++ b/keepalived/check/ipvswrapper.c
@@ -48,6 +48,20 @@ ipvs_get_group_by_name(char *gname, list l)
 	return NULL;
 }
 
+local_addr_group *
+ipvs_get_laddr_group_by_name(char *gname, list l)
+{
+	element e;
+	local_addr_group *laddr_group;
+
+	for (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {
+		laddr_group = ELEMENT_DATA(e);
+		if (!strcmp(laddr_group->gname, gname))
+			return laddr_group;
+	}
+	return NULL;
+}
+
 #ifdef _KRNL_2_4_			/* KERNEL 2.4 IPVS handling */
 
 /* Global module def IPVS rules */
@@ -328,6 +342,7 @@ ipvs_group_remove_entry(virtual_server_t *vs, virtual_server_group_entry_t *vsge
 static ipvs_service_t *srule;
 static ipvs_dest_t *drule;
 static ipvs_daemon_t *daemonrule;
+static ipvs_laddr_t *laddr_rule;
 
 /* Initialization helpers */
 int
@@ -347,6 +362,7 @@ ipvs_start(void)
 	srule = (ipvs_service_t *) MALLOC(sizeof(ipvs_service_t));
 	drule = (ipvs_dest_t *) MALLOC(sizeof(ipvs_dest_t));
 	daemonrule = (ipvs_daemon_t *) MALLOC(sizeof(ipvs_daemon_t));
+	laddr_rule = (ipvs_laddr_t *) MALLOC(sizeof(ipvs_laddr_t));
 	return IPVS_SUCCESS;
 }
 
@@ -357,6 +373,7 @@ ipvs_stop(void)
 	FREE(srule);
 	FREE(drule);
 	FREE(daemonrule);
+	FREE(laddr_rule);
 	ipvs_close();
 }
 
@@ -385,6 +402,12 @@ ipvs_talk(int cmd)
 		case IP_VS_SO_SET_ZERO:
 			result = ipvs_zero_service(srule);
 			break;
+		case IP_VS_SO_SET_ADDLADDR:
+			result = ipvs_add_laddr(srule, laddr_rule);
+			break;
+		case IP_VS_SO_SET_DELLADDR:
+			result = ipvs_del_laddr(srule, laddr_rule);
+			break;
 		case IP_VS_SO_SET_ADDDEST:
 			result = ipvs_add_dest(srule, drule);
 			break;
@@ -551,6 +574,9 @@ ipvs_set_rule(int cmd, virtual_server_t * vs, real_server_t * rs)
 		if (vs->granularity_persistence)
 			srule->netmask = vs->granularity_persistence;
 
+	if(vs->syn_proxy)
+		srule->flags |= IP_VS_CONN_F_SYNPROXY;
+
 	/* SVR specific */
 	if (rs) {
 		if (cmd == IP_VS_SO_SET_ADDDEST || cmd == IP_VS_SO_SET_DELDEST ||
@@ -568,10 +594,160 @@ ipvs_set_rule(int cmd, virtual_server_t * vs, real_server_t * rs)
 	}
 }
 
-/* Set/Remove a RS from a VS */
+static void
+ipvs_laddr_range_cmd(int cmd, local_addr_entry *laddr_entry)
+{
+	uint32_t addr_ip, ip;
+
+	memset(laddr_rule, 0, sizeof(ipvs_laddr_t));
+	laddr_rule->af = laddr_entry->addr.ss_family;
+	if (laddr_entry->addr.ss_family == AF_INET6) {
+		inet_sockaddrip6(&laddr_entry->addr, &laddr_rule->addr.in6);
+		ip = laddr_rule->addr.in6.s6_addr32[3];
+	} else {
+		ip = inet_sockaddrip4(&laddr_entry->addr);
+	}
+
+	for (addr_ip = ip; ((addr_ip >> 24) & 0xFF) <= laddr_entry->range;
+						     addr_ip += 0x01000000) {
+		if (laddr_entry->addr.ss_family == AF_INET6)
+			laddr_rule->addr.in6.s6_addr32[3] = addr_ip;
+		else
+			laddr_rule->addr.ip = addr_ip;
+
+		ipvs_talk(cmd);
+	}
+}
+
+static void
+ipvs_laddr_group_cmd(int cmd, local_addr_group *laddr_group)
+{
+	local_addr_entry *laddr_entry;
+	list l;
+	element e;
+
+	if (!laddr_group)
+		return;
+
+	l = laddr_group->addr_ip;
+	for (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {
+		laddr_entry = ELEMENT_DATA(e);
+		memset(laddr_rule, 0, sizeof(ipvs_laddr_t));
+		laddr_rule->af = laddr_entry->addr.ss_family;
+		if (laddr_entry->addr.ss_family == AF_INET6)
+			inet_sockaddrip6(&laddr_entry->addr, &laddr_rule->addr.in6);
+		else
+			laddr_rule->addr.ip = inet_sockaddrip4(&laddr_entry->addr);
+		ipvs_talk(cmd);
+	}
+
+	l = laddr_group->range;
+	for (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {
+		laddr_entry = ELEMENT_DATA(e);
+		ipvs_laddr_range_cmd(cmd, laddr_entry);
+	}
+}
+
+static void
+ipvs_laddr_vsg_cmd(int cmd, list vs_group, virtual_server_t * vs, local_addr_group *laddr_group)
+{
+	virtual_server_group_t *vsg = ipvs_get_group_by_name(vs->vsgname, vs_group);
+	virtual_server_group_entry_t *vsg_entry;
+	list l;
+	element e;
+
+	if (!vsg)
+		return;
+
+	/* visit addr_ip list */
+	l = vsg->addr_ip;
+	for (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {
+		vsg_entry = ELEMENT_DATA(e);
+
+		srule->af = vsg_entry->addr.ss_family;
+		if (srule->af == AF_INET6) {
+			if (srule->netmask == 0xffffffff)
+				srule->netmask = 128;
+			inet_sockaddrip6(&vsg_entry->addr, &srule->addr.in6);
+		} else
+			srule->addr.ip = inet_sockaddrip4(&vsg_entry->addr);
+		srule->port = inet_sockaddrport(&vsg_entry->addr);
+
+		/* local address group channel */
+		ipvs_laddr_group_cmd(cmd, laddr_group);
+	}
+
+	/* visit range list */
+	l = vsg->range;
+	for (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {
+		vsg_entry = ELEMENT_DATA(e);
+		uint32_t addr_ip, ip;
+		
+		srule->af = vsg_entry->addr.ss_family;
+		if (srule->af == AF_INET6) {
+			inet_sockaddrip6(&vsg_entry->addr, &srule->addr.in6);
+			ip = srule->addr.in6.s6_addr32[3];
+		} else {
+			ip = inet_sockaddrip4(&vsg_entry->addr);
+		}
+
+		/* Parse the whole range */
+		for (addr_ip = ip;
+		     ((addr_ip >> 24) & 0xFF) <= vsg_entry->range;
+		     addr_ip += 0x01000000) {
+			if (srule->af == AF_INET6) {
+				if (srule->netmask == 0xffffffff)
+					srule->netmask = 128;
+				srule->addr.in6.s6_addr32[3] = addr_ip;
+			} else {
+				srule->addr.ip = addr_ip;
+			}
+			srule->port = inet_sockaddrport(&vsg_entry->addr);
+
+			ipvs_laddr_group_cmd(cmd, laddr_group);
+		}
+	}
+}
+
+static int
+ipvs_laddr_cmd(int cmd, list vs_group, virtual_server_t * vs)
+{
+	local_addr_group *laddr_group = ipvs_get_laddr_group_by_name(vs->local_addr_gname, 
+							check_data->laddr_group);
+	if (!laddr_group) {
+		log_message(LOG_ERR, "No address in group %s", vs->local_addr_gname);
+		return IPVS_ERROR;
+	}
+
+	memset(srule, 0, sizeof(ipvs_service_t));
+	srule->netmask = (vs->addr.ss_family == AF_INET6) ? 128 : ((u_int32_t) 0xffffffff);
+	srule->protocol = vs->service_type;
+
+	if(vs->vsgname) {
+		ipvs_laddr_vsg_cmd(cmd, vs_group, vs, laddr_group);
+	} else {
+		if (!vs->vfwmark) {
+			srule->af = vs->addr.ss_family;
+			if (vs->addr.ss_family == AF_INET6)
+				inet_sockaddrip6(&vs->addr, &srule->addr.in6);
+			else
+				srule->addr.ip = inet_sockaddrip4(&vs->addr);
+			srule->port = inet_sockaddrport(&vs->addr);
+
+			ipvs_laddr_group_cmd(cmd, laddr_group);
+		}
+	}
+
+	return IPVS_SUCCESS;
+}
+
+/* Set/Remove a RS or a local address group from a VS */
 int
 ipvs_cmd(int cmd, list vs_group, virtual_server_t * vs, real_server_t * rs)
 {
+	/* Set/Remove local address */
+	if (cmd == IP_VS_SO_SET_ADDLADDR || cmd == IP_VS_SO_SET_DELLADDR)	
+		return ipvs_laddr_cmd(cmd, vs_group, vs);
 	/* Allocate the room */
 	memset(srule, 0, sizeof(ipvs_service_t));
 	ipvs_set_rule(cmd, vs, rs);
@@ -619,6 +795,119 @@ ipvs_cmd(int cmd, list vs_group, virtual_server_t * vs, real_server_t * rs)
 	return IPVS_SUCCESS;
 }
 
+static void 
+ipvs_rm_lentry_from_vsg(local_addr_entry *laddr_entry, char *vsgname)
+{
+	list l;
+	element e;
+	virtual_server_group_t *vsg;
+	virtual_server_group_entry_t *vsg_entry;
+
+	vsg = ipvs_get_group_by_name(vsgname, check_data->vs_group);
+	if (!vsg) return;
+
+	l = vsg->addr_ip;
+	for (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {
+		vsg_entry = ELEMENT_DATA(e);
+		srule->af = vsg_entry->addr.ss_family;
+		if (vsg_entry->addr.ss_family == AF_INET6) {
+			srule->netmask = 128;
+			inet_sockaddrip6(&vsg_entry->addr, &srule->addr.in6);
+		} else {
+			srule->netmask = 0xffffffff;
+			srule->addr.ip = inet_sockaddrip4(&vsg_entry->addr);
+		}
+		srule->port = inet_sockaddrport(&vsg_entry->addr);
+
+		if (laddr_entry->range)
+			ipvs_laddr_range_cmd(IP_VS_SO_SET_DELLADDR, laddr_entry);
+		else {
+			memset(laddr_rule, 0, sizeof(ipvs_laddr_t));
+			laddr_rule->af = laddr_entry->addr.ss_family;
+			if (laddr_entry->addr.ss_family == AF_INET6)
+				inet_sockaddrip6(&laddr_entry->addr, &laddr_rule->addr.in6);
+			else
+				laddr_rule->addr.ip = inet_sockaddrip4(&laddr_entry->addr);
+
+				ipvs_talk(IP_VS_SO_SET_DELLADDR);
+		}
+	}
+
+	l = vsg->range;
+	for (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {
+		vsg_entry = ELEMENT_DATA(e);
+		uint32_t addr_ip, ip;
+
+		srule->af = vsg_entry->addr.ss_family;
+		srule->netmask = (vsg_entry->addr.ss_family == AF_INET6) ? 128 : ((u_int32_t) 0xffffffff);
+		srule->port = inet_sockaddrport(&vsg_entry->addr);
+		if (vsg_entry->addr.ss_family == AF_INET6) {
+			inet_sockaddrip6(&vsg_entry->addr, &srule->addr.in6);
+			ip = srule->addr.in6.s6_addr32[3];
+		} else {
+			ip = inet_sockaddrip4(&vsg_entry->addr);
+		}
+
+		for (addr_ip = ip;
+		     ((addr_ip >> 24) & 0xFF) <= vsg_entry->range;
+		     addr_ip += 0x01000000) {
+			if (srule->af == AF_INET6)
+				srule->addr.in6.s6_addr32[3] = addr_ip;
+			else
+				srule->addr.ip = addr_ip;
+
+			if (laddr_entry->range)
+				ipvs_laddr_range_cmd(IP_VS_SO_SET_DELLADDR, laddr_entry);
+			else {
+				memset(laddr_rule, 0, sizeof(ipvs_laddr_t));
+				laddr_rule->af = laddr_entry->addr.ss_family;
+				if (laddr_entry->addr.ss_family == AF_INET6)
+					inet_sockaddrip6(&laddr_entry->addr, &laddr_rule->addr.in6);
+				else
+					laddr_rule->addr.ip = inet_sockaddrip4(&laddr_entry->addr);
+
+				ipvs_talk(IP_VS_SO_SET_DELLADDR);
+			}
+		}
+	}
+}
+
+int
+ipvs_laddr_remove_entry(virtual_server_t *vs, local_addr_entry *laddr_entry)
+{
+	memset(srule, 0, sizeof(ipvs_service_t));
+	srule->protocol = vs->service_type;
+
+	if (vs->vsgname) {
+		ipvs_rm_lentry_from_vsg(laddr_entry, vs->vsgname);
+	} else if (!vs->vfwmark) {
+		srule->af = vs->addr.ss_family;
+		if (vs->addr.ss_family == AF_INET6) {
+			srule->netmask = 128;
+			inet_sockaddrip6(&vs->addr, &srule->addr.in6);
+		} else {
+			srule->netmask = 0xffffffff;
+			srule->addr.ip = inet_sockaddrip4(&vs->addr);
+		}
+		srule->port = inet_sockaddrport(&vs->addr);
+
+		if (laddr_entry->range) {
+			ipvs_laddr_range_cmd(IP_VS_SO_SET_DELLADDR, laddr_entry);
+		} else {
+			memset(laddr_rule, 0, sizeof(ipvs_laddr_t));
+			laddr_rule->af = laddr_entry->addr.ss_family;
+			if (laddr_entry->addr.ss_family == AF_INET6)
+				inet_sockaddrip6(&laddr_entry->addr, &laddr_rule->addr.in6);
+			else
+				laddr_rule->addr.ip = inet_sockaddrip4(&laddr_entry->addr);
+
+			ipvs_talk(IP_VS_SO_SET_DELLADDR);
+		}
+	}
+
+	return IPVS_SUCCESS;
+}
+
 /* Remove a specific vs group entry */
 int
 ipvs_group_remove_entry(virtual_server_t *vs, virtual_server_group_entry_t *vsge)
@@ -670,11 +959,23 @@ ipvs_group_remove_entry(virtual_server_t *vs, virtual_server_group_entry_t *vsge
 		}
 	}
 
+	/* In case of all rs is unalive */
+	ipvs_set_rule(IP_VS_SO_SET_DEL, vs, NULL);
+
 	/* Remove VS entry */
 	if (vsge->range)
 		ipvs_group_range_cmd(IP_VS_SO_SET_DEL, vsge);
-	else
+	else {
+		srule->af = vsge->addr.ss_family;
+		if (vsge->addr.ss_family == AF_INET6)
+			inet_sockaddrip6(&vsge->addr, &srule->addr.in6);
+		else
+			srule->addr.ip = inet_sockaddrip4(&vsge->addr);
+		srule->port = inet_sockaddrport(&vsge->addr);
+		srule->fwmark = vsge->vfwmark;
+
 		ipvs_talk(IP_VS_SO_SET_DEL);
+	}
 
 	return IPVS_SUCCESS;
 }
diff --git a/keepalived/check/ipwrapper.c b/keepalived/check/ipwrapper.c
index 878f576..9f4bf35 100644
--- a/keepalived/check/ipwrapper.c
+++ b/keepalived/check/ipwrapper.c
@@ -32,6 +32,264 @@
 #endif
 
 /* out-of-order functions declarations */
+#include "vrrp_if.h"
+#include "vrrp_netlink.h"
+
+
+static struct {
+	struct nlmsghdr n;
+	struct ifaddrmsg ifa;
+	char buf[256];
+} req;
+
+/* send message to netlink kernel socket, ignore response */
+int
+netlink_cmd(nl_handle_t *nl, struct nlmsghdr *n)
+{
+	int status;
+	struct sockaddr_nl snl;
+	struct iovec iov = { (void *) n, n->nlmsg_len };
+	struct msghdr msg = { (void *) &snl, sizeof snl, &iov, 1, NULL, 0, 0 };
+
+	memset(&snl, 0, sizeof snl);
+	snl.nl_family = AF_NETLINK;
+
+	n->nlmsg_seq = ++nl->seq;
+
+	/* Request Netlink acknowledgement */
+//	n->nlmsg_flags |= NLM_F_ACK;
+
+	/* Send message to netlink interface. */
+	status = sendmsg(nl->fd, &msg, 0);
+	if (status < 0) {
+		log_message(LOG_INFO, "Netlink: sendmsg() error: %s",
+		       strerror(errno));
+		return -1;
+	}
+
+	return status;
+}
+
+/* ip range handle. the req messgage must be set */
+void
+netlink_range_cmd(int cmd, virtual_server_group_entry_t *vsg_entry)
+{
+	uint32_t addr_ip, ip;
+	struct in6_addr addr_v6;
+	struct in_addr addr_v4;
+	struct sockaddr_storage *addr = &vsg_entry->addr;
+
+	log_message(LOG_INFO, "%s VIP Range %s-%d"
+			    , cmd ? "ADD":"DEL"
+			    , inet_sockaddrtos(&vsg_entry->addr)
+			    , vsg_entry->range);
+
+	req.n.nlmsg_type = cmd ? RTM_NEWADDR : RTM_DELADDR;
+	req.ifa.ifa_family = addr->ss_family;
+	if(req.ifa.ifa_family == AF_INET6) {
+		req.ifa.ifa_prefixlen = 128;
+		inet_sockaddrip6(addr, &addr_v6);
+		ip = addr_v6.s6_addr32[3];
+
+		/* Parse the whole range */
+		for (addr_ip = ip;
+				((addr_ip >> 24) & 0xFF) <= vsg_entry->range;
+				addr_ip += 0x01000000) {
+			/* nlmsg_len will modify by addattr_l(). 
+			 * It must be reset in each circle.
+			 */
+			req.n.nlmsg_len = NLMSG_LENGTH(sizeof (struct ifaddrmsg));
+
+			addr_v6.s6_addr32[3] = addr_ip;
+			addattr_l(&req.n, sizeof(req), IFA_LOCAL,
+					&addr_v6, sizeof(struct in6_addr));
+			if (netlink_cmd(&nl_cmd, &req.n) < 0)
+				log_message(LOG_INFO, "%s VIP range failed, at %d",
+						cmd ? "ADD":"DEL",
+						((addr_ip >> 24) & 0xFF));
+
+		}
+	} else {
+		req.ifa.ifa_prefixlen = 32;
+		addr_v4 = ((struct sockaddr_in *)addr)->sin_addr;
+		ip = addr_v4.s_addr;
+
+		/* Parse the whole range */
+		for (addr_ip = ip;
+				((addr_ip >> 24) & 0xFF) <= vsg_entry->range;
+				addr_ip += 0x01000000) {
+			req.n.nlmsg_len = NLMSG_LENGTH(sizeof (struct ifaddrmsg));
+			addr_v4.s_addr = addr_ip;
+			addattr_l(&req.n, sizeof(req), IFA_LOCAL,
+					&addr_v4, sizeof(struct in_addr));
+			if (netlink_cmd(&nl_cmd, &req.n) < 0)
+				log_message(LOG_INFO, "%s VIP range failed, at %d",
+						cmd ? "ADD":"DEL",
+						((addr_ip >> 24) & 0xFF));
+		}
+	}
+}
+
+/* call by netlink_vipaddress() only */
+int
+netlink_group_vipaddress(list vs_group, char * vsgname, int cmd)
+{
+	virtual_server_group_t *vsg = ipvs_get_group_by_name(vsgname, vs_group);
+	virtual_server_group_entry_t *vsg_entry;
+	struct sockaddr_storage *addr;
+	list l;
+	element e;
+	int err = 1;
+
+	if (!vsg) return -1;
+
+	/* visit addr_ip list */
+	l = vsg->addr_ip;
+	for (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {
+		vsg_entry = ELEMENT_DATA(e);
+
+		addr = &vsg_entry->addr;
+		req.n.nlmsg_len = NLMSG_LENGTH(sizeof (struct ifaddrmsg));
+		req.ifa.ifa_family = addr->ss_family;
+		if(req.ifa.ifa_family == AF_INET6) {
+			req.ifa.ifa_prefixlen = 128;
+			addattr_l(&req.n, sizeof(req), IFA_LOCAL,
+				&((struct sockaddr_in6 *)addr)->sin6_addr,
+						sizeof(struct in6_addr));
+		} else {
+			req.ifa.ifa_prefixlen = 32;
+			addattr_l(&req.n, sizeof(req), IFA_LOCAL,
+				&((struct sockaddr_in *)addr)->sin_addr,
+						sizeof(struct in_addr));
+		}
+
+		log_message(LOG_INFO, "%s VIP %s",
+					cmd ? "ADD":"DEL", inet_sockaddrtos(addr));
+		if (netlink_cmd(&nl_cmd, &req.n) < 0)
+			log_message(LOG_INFO, "%s VIP = %s failed",
+						cmd ? "ADD":"DEL",
+						inet_sockaddrtos(addr));
+	}
+
+	/* visit range list */
+	l = vsg->range;
+	for (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {
+		vsg_entry = ELEMENT_DATA(e);
+
+		netlink_range_cmd(cmd, vsg_entry);
+	}
+
+	return err;
+}
+
+/* add/del VIP from a VS */
+int
+netlink_vipaddress(list vs_group, virtual_server_t *vs, int cmd)
+{
+	unsigned int ifa_idx;
+
+	memset(&req, 0, sizeof (req));
+
+	req.n.nlmsg_len = NLMSG_LENGTH(sizeof (struct ifaddrmsg));
+	req.n.nlmsg_flags = NLM_F_REQUEST;
+	req.n.nlmsg_type = cmd ? RTM_NEWADDR : RTM_DELADDR;
+
+	if (vs->vip_bind_dev) {
+		ifa_idx = if_nametoindex(vs->vip_bind_dev);
+//		log_message(LOG_INFO, "vip_bind_dev: %s", vs->vip_bind_dev);
+	} else {
+		return 0;
+//		ifa_idx = if_nametoindex("lo");
+//		log_message(LOG_INFO, "vip_bind_dev isn't set.
+//						Use default interface lo");
+	}
+	if (!ifa_idx) {
+		log_message(LOG_INFO, "interface %s does not exist",
+							vs->vip_bind_dev);
+		return 0;
+	}
+
+	req.ifa.ifa_index = ifa_idx;
+
+	if (vs->vfwmark)
+		 log_message(LOG_INFO, " VS FWMARK, skip");
+	else if(vs->vsgname) {
+		netlink_group_vipaddress(vs_group, vs->vsgname, cmd);
+	} else {
+		req.ifa.ifa_family = vs->addr.ss_family;
+		if(req.ifa.ifa_family == AF_INET6) {
+			req.ifa.ifa_prefixlen = 128;
+			addattr_l(&req.n, sizeof(req), IFA_LOCAL,
+				&((struct sockaddr_in6 *)&vs->addr)->sin6_addr,
+						sizeof(struct in6_addr));
+		} else {
+			req.ifa.ifa_prefixlen = 32;
+			addattr_l(&req.n, sizeof(req), IFA_LOCAL,
+				&((struct sockaddr_in *)&vs->addr)->sin_addr,
+						sizeof(struct in_addr));
+		}
+
+		log_message(LOG_INFO, "%s VIP %s to %s",
+					cmd ? "ADD":"DEL",
+					inet_sockaddrtos(&vs->addr),
+					vs->vip_bind_dev);
+		if (netlink_cmd(&nl_cmd, &req.n) < 0)
+			log_message(LOG_INFO, "%s VIP = %s failed",
+						cmd ? "ADD":"DEL",
+						inet_sockaddrtos(&vs->addr));
+	}
+
+	return 1;
+}
+
+/* Remove  IP of the specific vs group entry */
+void
+netlink_group_remove_entry(virtual_server_t *vs, virtual_server_group_entry_t *vsge)
+{
+	unsigned int ifa_idx;
+	struct sockaddr_storage *addr;
+
+	memset(&req, 0, sizeof (req));
+
+	req.n.nlmsg_len = NLMSG_LENGTH(sizeof (struct ifaddrmsg));
+	req.n.nlmsg_flags = NLM_F_REQUEST;
+	req.n.nlmsg_type = RTM_DELADDR;
+
+	if (!vs->vip_bind_dev)
+		return;
+
+	ifa_idx = if_nametoindex(vs->vip_bind_dev);
+	if (!ifa_idx) {
+		log_message(LOG_INFO, "interface %s does not exist",
+							vs->vip_bind_dev);
+		return;
+	}
+
+	req.ifa.ifa_index = ifa_idx;
+
+	if (vsge->range) {
+		netlink_range_cmd(DOWN, vsge);
+	} else {
+		addr = &vsge->addr;
+		req.ifa.ifa_family = addr->ss_family;
+		if(req.ifa.ifa_family == AF_INET6) {
+			req.ifa.ifa_prefixlen = 128;
+			addattr_l(&req.n, sizeof(req), IFA_LOCAL,
+				&((struct sockaddr_in6 *)addr)->sin6_addr,
+						sizeof(struct in6_addr));
+		} else {
+			req.ifa.ifa_prefixlen = 32;
+			addattr_l(&req.n, sizeof(req), IFA_LOCAL,
+				&((struct sockaddr_in *)addr)->sin_addr,
+						sizeof(struct in_addr));
+		}
+
+		log_message(LOG_INFO, "DEL VIP %s", inet_sockaddrtos(addr));
+		if (netlink_cmd(&nl_cmd, &req.n) < 0)
+			log_message(LOG_INFO, "DEL VIP = %s failed",
+						inet_sockaddrtos(addr));
+	}
+}
 static void update_quorum_state(virtual_server_t * vs);
 
 /* Returns the sum of all RS weight in a virtual server. */
@@ -94,6 +352,7 @@ clear_service_rs(list vs_group, virtual_server_t * vs, list l)
 				weight_sum < vs->quorum - vs->hysteresis)
 			) {
 				vs->quorum_state = DOWN;
+				netlink_vipaddress(vs_group, vs, DOWN);
 				if (vs->quorum_down) {
 					log_message(LOG_INFO, "Executing [%s] for VS %s"
 							    , vs->quorum_down
@@ -194,12 +453,21 @@ init_service_vs(virtual_server_t * vs)
 			SET_ALIVE(vs);
 	}
 
+	/*Set local ip address in "FNAT" mode of IPVS */
+	if ((vs->loadbalancing_kind == IP_VS_CONN_F_FULLNAT) && vs->local_addr_gname) { 
+		if (!ipvs_cmd(LVS_CMD_ADD_LADDR, check_data->vs_group, vs, NULL))
+			return 0; 
+	}
+
 	/* Processing real server queue */
 	if (!LIST_ISEMPTY(vs->rs)) {
-		if (vs->alpha && ! vs->reloaded)
-			vs->quorum_state = DOWN;
 		if (!init_service_rs(vs))
 			return 0;
+
+		if (vs->alpha && ! vs->reloaded)
+			vs->quorum_state = DOWN;
+		else
+			netlink_vipaddress(check_data->vs_group, vs, UP);
 	}
 
 	/* if the service was reloaded, we may have got/lost quorum due to quorum setting changed */
@@ -277,6 +545,7 @@ update_quorum_state(virtual_server_t * vs)
 			/* Adding back alive real servers */
 			perform_quorum_state(vs, 1);
 		}
+		netlink_vipaddress(check_data->vs_group, vs, UP);
 		if (vs->quorum_up) {
 			log_message(LOG_INFO, "Executing [%s] for VS %s"
 					    , vs->quorum_up
@@ -303,6 +572,7 @@ update_quorum_state(virtual_server_t * vs)
 				    , vs->quorum - vs->hysteresis
 				    , weight_sum
 				    , FMT_VS(vs));
+		netlink_vipaddress(check_data->vs_group, vs, DOWN);
 		if (vs->quorum_down) {
 			log_message(LOG_INFO, "Executing [%s] for VS %s"
 					    , vs->quorum_down
@@ -421,12 +691,32 @@ update_svr_wgt(int weight, virtual_server_t * vs, real_server_t * rs)
 
 /* Test if realserver is marked UP for a specific checker */
 int
-svr_checker_up(checker_id_t cid, real_server_t *rs)
+svr_checker_up(int alive, checker_id_t cid, real_server_t *rs)
 {
 	element e;
 	list l = rs->failed_checkers;
 	checker_id_t *id;
 
+	if (rs->reloaded) {
+		/* first check failed under alpha mode
+		 * and the rs is alive before reload
+		 */
+		if (!alive && !ISALIVE(rs)) {
+			element next;
+
+			for (e = LIST_HEAD(l); e; e = next) {
+				next = e->next;
+				free_list_element(l, e);
+			}
+			l->head = NULL;
+			l->tail = NULL;
+
+			SET_ALIVE(rs);
+		}
+		/* make sure we do not go here next time */
+		rs->reloaded = 0;
+	}
+
 	/*
 	 * We assume there is not too much checker per
 	 * real server, so we consider this lookup as
@@ -520,6 +810,9 @@ clear_diff_vsge(list old, list new, virtual_server_t * old_vs)
 
 			if (!ipvs_group_remove_entry(old_vs, vsge))
 				return 0;
+
+			if (old_vs->vip_bind_dev && (old_vs->quorum_state == UP))
+				netlink_group_remove_entry(old_vs, vsge);
 		}
 	}
 
@@ -578,6 +871,10 @@ vs_exist(virtual_server_t * old_vs)
 			 * Exist so set alive.
 			 */
 			SET_ALIVE(vs);
+			if ((old_vs->vip_bind_dev && vs->vip_bind_dev &&
+				strcmp(old_vs->vip_bind_dev, vs->vip_bind_dev)) ||
+				(old_vs->vip_bind_dev != NULL && vs->vip_bind_dev == NULL))
+				netlink_vipaddress(old_check_data->vs_group, old_vs, DOWN);
 			return vs;
 		}
 	}
@@ -606,6 +903,11 @@ rs_exist(real_server_t * old_rs, list l)
 			rs->alive = old_rs->alive;
 			rs->set = old_rs->set;
 			rs->weight = old_rs->weight;
+			/*
+			 * The alpha mode will reset rs to unalive.
+			 * We save the status before reload here
+			 */
+			rs->reloaded = rs->alive;
 			return 1;
 		}
 	}
@@ -656,6 +958,9 @@ clear_diff_rs(list old_vs_group, virtual_server_t * old_vs)
 			log_message(LOG_INFO, "service %s no longer exist"
 					    , FMT_RS(rs));
 			rs->inhibit = 0;
+			/* Set alive flag to delete the failed inhibit entries */
+			if (old_vs->vsgname)
+				SET_ALIVE(rs);
 			list_add (rs_to_remove, rs);
 		}
 	}
@@ -665,6 +970,74 @@ clear_diff_rs(list old_vs_group, virtual_server_t * old_vs)
 	return ret;
 }
 
+/* Check if a local address entry is in list */
+static int
+laddr_entry_exist(local_addr_entry *laddr_entry, list l)
+{
+	element e;
+	local_addr_entry *entry;
+
+	for (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {
+		entry = ELEMENT_DATA(e);
+		if (sockstorage_equal(&entry->addr, &laddr_entry->addr) && 
+						entry->range == laddr_entry->range)
+			return 1;
+	}
+
+	return 0;
+}
+
+/* Clear the diff local address entry of eth old vs */
+static int
+clear_diff_laddr_entry(list old, list new, virtual_server_t * old_vs)
+{
+	element e;
+	local_addr_entry *laddr_entry;
+
+	for (e = LIST_HEAD(old); e; ELEMENT_NEXT(e)) {
+		laddr_entry = ELEMENT_DATA(e);
+		if (!laddr_entry_exist(laddr_entry, new)) {
+			log_message(LOG_INFO, "VS [%s-%d] in local address group %s no longer exist\n" 
+					    , inet_sockaddrtos(&laddr_entry->addr)
+					    , laddr_entry->range
+					    , old_vs->local_addr_gname);
+
+			if (!ipvs_laddr_remove_entry(old_vs, laddr_entry))
+				return 0;
+		}
+	}
+
+	return 1;
+}
+
+/* Clear the diff local address of the old vs */
+static int
+clear_diff_laddr(virtual_server_t * old_vs)
+{
+	local_addr_group *old;
+	local_addr_group *new;
+
+	/*
+ 	 *  If old vs was not in fulllnat mod or didn't own local address group, 
+ 	 * then do nothing and return 
+ 	 */
+	if ((old_vs->loadbalancing_kind != IP_VS_CONN_F_FULLNAT) || 
+						!old_vs->local_addr_gname)
+		return 1;
+
+	/* Fetch local address group */
+	old = ipvs_get_laddr_group_by_name(old_vs->local_addr_gname, 
+							old_check_data->laddr_group);
+	new = ipvs_get_laddr_group_by_name(old_vs->local_addr_gname, 
+							check_data->laddr_group);
+
+	if (!clear_diff_laddr_entry(old->addr_ip, new->addr_ip, old_vs))
+		return 0;
+	if (!clear_diff_laddr_entry(old->range, new->range, old_vs))
+		return 0;
+
+	return 1;
+}
 /* When reloading configuration, remove negative diff entries */
 int
 clear_diff_services(void)
@@ -710,9 +1083,11 @@ clear_diff_services(void)
 						      , vs
 						      , vs->s_svr))
 						return 0;
+			/* perform local address diff */
+			if (!clear_diff_laddr(vs))
+				return 0;
 		}
 	}
-
 	return 1;
 }
 
diff --git a/keepalived/include/check_data.h b/keepalived/include/check_data.h
index f634633..b2eb456 100644
--- a/keepalived/include/check_data.h
+++ b/keepalived/include/check_data.h
@@ -93,6 +93,18 @@ typedef struct _real_server {
 #endif
 } real_server_t;
 
+/* local ip address group definition */
+typedef struct _local_addr_entry {
+	struct sockaddr_storage addr;
+	uint8_t range;
+} local_addr_entry;
+
+typedef struct _local_addr_group {
+	char *gname;
+	list addr_ip;
+	list range;
+} local_addr_group;
+
 /* Virtual Server group definition */
 typedef struct _virtual_server_group_entry {
 	struct sockaddr_storage		addr;
@@ -128,6 +140,7 @@ typedef struct _virtual_server {
 	int				alive;
 	unsigned			alpha;		/* Alpha mode enabled. */
 	unsigned			omega;		/* Omega mode enabled. */
+	unsigned            syn_proxy;	/* Syn_proxy mode enabled. */
 	char				*quorum_up;	/* A hook to call when the VS gains quorum. */
 	char				*quorum_down;	/* A hook to call when the VS loses quorum. */
 	long unsigned			quorum;		/* Minimum live RSs to consider VS up. */
@@ -140,6 +153,8 @@ typedef struct _virtual_server {
 	time_t				lastupdated;
 	struct ip_vs_stats_user		stats;
 #endif
+	char *local_addr_gname;		/* local ip address group name */
+	char *vip_bind_dev;		/* the interface name,vip bindto */
 } virtual_server_t;
 
 /* Configuration data root */
@@ -147,6 +162,7 @@ typedef struct _check_data {
 	ssl_data_t			*ssl;
 	list				vs_group;
 	list				vs;
+	list laddr_group;
 } check_data_t;
 
 /* inline stuff */
@@ -219,6 +235,7 @@ static inline int inaddr_equal(sa_family_t family, void *addr1, void *addr2)
 			 (X)->loadbalancing_kind      == (Y)->loadbalancing_kind	&&\
 			 (X)->nat_mask                == (Y)->nat_mask			&&\
 			 (X)->granularity_persistence == (Y)->granularity_persistence	&&\
+			 (X)->syn_proxy		      == (Y)->syn_proxy			&&\
 			 (  (!(X)->quorum_up && !(Y)->quorum_up) || \
 			    ((X)->quorum_up && (Y)->quorum_up && !strcmp ((X)->quorum_up, (Y)->quorum_up)) \
 			 ) &&\
@@ -226,7 +243,10 @@ static inline int inaddr_equal(sa_family_t family, void *addr1, void *addr2)
 			 !strcmp((X)->timeout_persistence, (Y)->timeout_persistence)	&&\
 			 (((X)->vsgname && (Y)->vsgname &&				\
 			   !strcmp((X)->vsgname, (Y)->vsgname)) || 			\
-			  (!(X)->vsgname && !(Y)->vsgname)))
+			  (!(X)->vsgname && !(Y)->vsgname))				&&\
+			 (((X)->local_addr_gname && (Y)->local_addr_gname &&		\
+			   !strcmp((X)->local_addr_gname, (Y)->local_addr_gname)) ||	\
+			  (!(X)->local_addr_gname && !(Y)->local_addr_gname)))
 
 #define VSGE_ISEQ(X,Y)	(sockstorage_equal(&(X)->addr,&(Y)->addr) &&	\
 			 (X)->range     == (Y)->range &&		\
@@ -242,6 +262,8 @@ extern check_data_t *old_check_data;
 /* prototypes */
 extern ssl_data_t *alloc_ssl(void);
 extern void free_ssl(void);
+extern void alloc_laddr_group(char *);
+extern void alloc_laddr_entry(vector_t *);
 extern void alloc_vsg(char *);
 extern void alloc_vsg_entry(vector_t *);
 extern void alloc_vs(char *, char *);
diff --git a/keepalived/include/ipvswrapper.h b/keepalived/include/ipvswrapper.h
index ea041c3..c6713ff 100644
--- a/keepalived/include/ipvswrapper.h
+++ b/keepalived/include/ipvswrapper.h
@@ -93,6 +93,8 @@ extern int ipvs_start(void);
 extern void ipvs_stop(void);
 extern virtual_server_group_t *ipvs_get_group_by_name(char *, list);
 extern int ipvs_group_remove_entry(virtual_server_t *, virtual_server_group_entry_t *);
+extern local_addr_group *ipvs_get_laddr_group_by_name(char *, list);
+extern int ipvs_laddr_remove_entry(virtual_server_t *, local_addr_entry *);
 extern int ipvs_cmd(int, list, virtual_server_t *, real_server_t *);
 extern int ipvs_syncd_cmd(int, char *, int, int);
 extern void ipvs_syncd_master(char *, int);
diff --git a/keepalived/include/ipwrapper.h b/keepalived/include/ipwrapper.h
index 0366cb0..2002449 100644
--- a/keepalived/include/ipwrapper.h
+++ b/keepalived/include/ipwrapper.h
@@ -47,11 +47,13 @@
 #define LVS_CMD_ADD_DEST	IP_VS_SO_SET_ADDDEST
 #define LVS_CMD_DEL_DEST	IP_VS_SO_SET_DELDEST
 #define LVS_CMD_EDIT_DEST	IP_VS_SO_SET_EDITDEST
+#define LVS_CMD_ADD_LADDR	IP_VS_SO_SET_ADDLADDR
+#define LVS_CMD_DEL_LADDR       IP_VS_SO_SET_DELLADDR
 
 /* prototypes */
 extern void perform_svr_state(int, virtual_server_t *, real_server_t *);
 extern void update_svr_wgt(int, virtual_server_t *, real_server_t *);
-extern int svr_checker_up(checker_id_t, real_server_t *);
+extern int svr_checker_up(int, checker_id_t, real_server_t *);
 extern void update_svr_checker_state(int, checker_id_t, virtual_server_t *, real_server_t *);
 extern int init_services(void);
 extern int clear_services(void);
diff --git a/keepalived/libipvs-2.6/ip_vs.h b/keepalived/libipvs-2.6/ip_vs.h
index 2265b4c..a100057 100644
--- a/keepalived/libipvs-2.6/ip_vs.h
+++ b/keepalived/libipvs-2.6/ip_vs.h
@@ -38,6 +38,7 @@
 #define IP_VS_SVC_F_SCHED1	0x0008		/* scheduler flag 1 */
 #define IP_VS_SVC_F_SCHED2	0x0010		/* scheduler flag 2 */
 #define IP_VS_SVC_F_SCHED3	0x0020		/* scheduler flag 3 */
+#define IP_VS_CONN_F_SYNPROXY	0x8000	/* synproxy switch flag*/
 
 #define IP_VS_SVC_F_SCHED_SH_FALLBACK	IP_VS_SVC_F_SCHED1 /* SH fallback */
 #define IP_VS_SVC_F_SCHED_SH_PORT	IP_VS_SVC_F_SCHED2 /* SH use port */
@@ -71,7 +72,9 @@
 #define IP_VS_SO_SET_RESTORE    (IP_VS_BASE_CTL+13)
 #define IP_VS_SO_SET_SAVE       (IP_VS_BASE_CTL+14)
 #define IP_VS_SO_SET_ZERO	(IP_VS_BASE_CTL+15)
-#define IP_VS_SO_SET_MAX	IP_VS_SO_SET_ZERO
+#define IP_VS_SO_SET_ADDLADDR	(IP_VS_BASE_CTL+16)
+#define IP_VS_SO_SET_DELLADDR	(IP_VS_BASE_CTL+17)
+#define IP_VS_SO_SET_MAX	IP_VS_SO_SET_DELLADDR	
 
 #define IP_VS_SO_GET_VERSION	IP_VS_BASE_CTL
 #define IP_VS_SO_GET_INFO	(IP_VS_BASE_CTL+1)
@@ -81,7 +84,8 @@
 #define IP_VS_SO_GET_DEST	(IP_VS_BASE_CTL+5)	/* not used now */
 #define IP_VS_SO_GET_TIMEOUT	(IP_VS_BASE_CTL+6)
 #define IP_VS_SO_GET_DAEMON	(IP_VS_BASE_CTL+7)
-#define IP_VS_SO_GET_MAX	IP_VS_SO_GET_DAEMON
+#define IP_VS_SO_GET_LADDRS	(IP_VS_BASE_CTL+8)
+#define IP_VS_SO_GET_MAX	IP_VS_SO_GET_LADDRS
 
 
 /*
@@ -93,6 +97,7 @@
 #define IP_VS_CONN_F_TUNNEL	0x0002		/* tunneling */
 #define IP_VS_CONN_F_DROUTE	0x0003		/* direct routing */
 #define IP_VS_CONN_F_BYPASS	0x0004		/* cache bypass */
+#define IP_VS_CONN_F_FULLNAT	0x0005		/* full nat mode */
 #define IP_VS_CONN_F_SYNC	0x0020		/* entry created by sync */
 #define IP_VS_CONN_F_HASHED	0x0040		/* hashed entry */
 #define IP_VS_CONN_F_NOOUTPUT	0x0080		/* no output packets */
@@ -183,14 +188,25 @@ struct ip_vs_dest_user {
 	union nf_inet_addr	addr;
 };
 
+struct ip_vs_laddr_kern {
+	__be32			addr;	/* ipv4 address */
+};
+
+
+struct ip_vs_laddr_user {
+	__be32			__addr_v4;	/* ipv4 address */
+	u_int16_t		af;
+	union nf_inet_addr	addr;
+};
+
 /*
  *	IPVS statistics object (for user space)
  */
 struct ip_vs_stats_user
 {
-	__u32                   conns;          /* connections scheduled */
-	__u32                   inpkts;         /* incoming packets */
-	__u32                   outpkts;        /* outgoing packets */
+	__u64                   conns;          /* connections scheduled */
+	__u64                   inpkts;         /* incoming packets */
+	__u64                   outpkts;        /* outgoing packets */
 	__u64                   inbytes;        /* incoming bytes */
 	__u64                   outbytes;       /* outgoing bytes */
 
@@ -231,6 +247,8 @@ struct ip_vs_service_entry_kern {
 
 	/* number of real servers */
 	unsigned int		num_dests;
+	/* number of local address*/
+	unsigned int		num_laddrs;
 
 	/* statistics */
 	struct ip_vs_stats_user stats;
@@ -251,6 +269,8 @@ struct ip_vs_service_entry {
 
 	/* number of real servers */
 	unsigned int		num_dests;
+	/* number of local address*/
+	unsigned int		num_laddrs;
 
 	/* statistics */
 	struct ip_vs_stats_user stats;
@@ -297,6 +317,51 @@ struct ip_vs_dest_entry {
 	union nf_inet_addr	addr;
 };
 
+struct ip_vs_laddr_entry_kern {
+	__be32			__addr_v4;	/* local address - internal use only */
+	u_int64_t		port_conflict;	/* conflict counts */
+	u_int32_t		conn_counts;	/* current connects */
+};
+
+struct ip_vs_laddr_entry {
+	__be32			__addr_v4;	/* local address - internal use only */
+	u_int64_t		port_conflict;	/* conflict counts */
+	u_int32_t		conn_counts;	/* current connects */
+	u_int16_t		af;
+	union nf_inet_addr	addr;
+};
+
+/* The argument to IP_VS_SO_GET_LADDRS */
+struct ip_vs_get_laddrs_kern {
+	/* which service: user fills in these */
+	u_int16_t		protocol;
+	__be32			addr;	/* virtual address - internal use only */
+	__be16			port;
+	u_int32_t		fwmark;		/* firwall mark of service */
+
+	/* number of local address*/
+	unsigned int		num_laddrs;
+
+	/* the real servers */
+	struct ip_vs_laddr_entry_kern	entrytable[0];
+};
+
+struct ip_vs_get_laddrs {
+	/* which service: user fills in these */
+	u_int16_t		protocol;
+	__be32			__addr_v4;	/* virtual address - internal use only */
+	__be16			port;
+	u_int32_t		fwmark;		/* firwall mark of service */
+
+	/* number of local address*/
+	unsigned int		num_laddrs;
+	u_int16_t		af;
+	union nf_inet_addr	addr;
+
+	/* the real servers */
+	struct ip_vs_laddr_entry	entrytable[0];
+};
+
 /* The argument to IP_VS_SO_GET_DESTS */
 struct ip_vs_get_dests_kern {
 	/* which service: user fills in these */
@@ -312,6 +377,7 @@ struct ip_vs_get_dests_kern {
 	struct ip_vs_dest_entry_kern	entrytable[0];
 };
 
+
 struct ip_vs_get_dests {
 	/* which service: user fills in these */
 	u_int16_t		protocol;
@@ -409,6 +475,10 @@ enum {
 	IPVS_CMD_ZERO,			/* zero all counters and stats */
 	IPVS_CMD_FLUSH,			/* flush services and dests */
 
+	IPVS_CMD_NEW_LADDR , 
+	IPVS_CMD_DEL_LADDR , 
+	IPVS_CMD_GET_LADDR , 
+
 	__IPVS_CMD_MAX,
 };
 
@@ -423,6 +493,7 @@ enum {
 	IPVS_CMD_ATTR_TIMEOUT_TCP,	/* TCP connection timeout */
 	IPVS_CMD_ATTR_TIMEOUT_TCP_FIN,	/* TCP FIN wait timeout */
 	IPVS_CMD_ATTR_TIMEOUT_UDP,	/* UDP timeout */
+	IPVS_CMD_ATTR_LADDR , 		/* local address */
 	__IPVS_CMD_ATTR_MAX,
 };
 
@@ -482,6 +553,21 @@ enum {
 #define IPVS_DEST_ATTR_MAX (__IPVS_DEST_ATTR_MAX - 1)
 
 /*
+ * Attirbutes used to describe a local address
+ *
+ */
+
+enum {
+	IPVS_LADDR_ATTR_UNSPEC = 0 , 
+	IPVS_LADDR_ATTR_ADDR,
+	IPVS_LADDR_ATTR_PORT_CONFLICT,
+	IPVS_LADDR_ATTR_CONN_COUNTS, 
+	__IPVS_LADDR_ATTR_MAX , 
+};
+
+#define IPVS_LADDR_ATTR_MAX (__IPVS_LADDR_ATTR_MAX - 1)
+
+/*
  * Attributes describing a sync daemon
  *
  * Used inside nested attribute IPVS_CMD_ATTR_DAEMON
@@ -536,6 +622,7 @@ extern struct nla_policy ipvs_dest_policy[IPVS_DEST_ATTR_MAX + 1];
 extern struct nla_policy ipvs_stats_policy[IPVS_STATS_ATTR_MAX + 1];
 extern struct nla_policy ipvs_info_policy[IPVS_INFO_ATTR_MAX + 1];
 extern struct nla_policy ipvs_daemon_policy[IPVS_DAEMON_ATTR_MAX + 1];
+extern struct nla_policy ipvs_laddr_policy[IPVS_LADDR_ATTR_MAX + 1];
 #endif
 
 /* End of Generic Netlink interface definitions */
diff --git a/keepalived/libipvs-2.6/ip_vs_nl_policy.c b/keepalived/libipvs-2.6/ip_vs_nl_policy.c
index c80083e..045bcdc 100644
--- a/keepalived/libipvs-2.6/ip_vs_nl_policy.c
+++ b/keepalived/libipvs-2.6/ip_vs_nl_policy.c
@@ -9,6 +9,7 @@ struct nla_policy ipvs_cmd_policy[IPVS_CMD_ATTR_MAX + 1] = {
 	[IPVS_CMD_ATTR_TIMEOUT_TCP]	= { .type = NLA_U32 },
 	[IPVS_CMD_ATTR_TIMEOUT_TCP_FIN]	= { .type = NLA_U32 },
 	[IPVS_CMD_ATTR_TIMEOUT_UDP]	= { .type = NLA_U32 },
+	[IPVS_CMD_ATTR_LADDR]		= { .type = NLA_NESTED},
 };
 
 struct nla_policy ipvs_service_policy[IPVS_SVC_ATTR_MAX + 1] = {
@@ -42,10 +43,17 @@ struct nla_policy ipvs_dest_policy[IPVS_DEST_ATTR_MAX + 1] = {
 	[IPVS_DEST_ATTR_STATS]		= { .type = NLA_NESTED },
 };
 
+struct nla_policy ipvs_laddr_policy[IPVS_LADDR_ATTR_MAX + 1] = {
+	[IPVS_LADDR_ATTR_ADDR]		= { .type = NLA_UNSPEC,
+					    .maxlen = sizeof(struct in6_addr) },
+	[IPVS_LADDR_ATTR_PORT_CONFLICT]   = { .type = NLA_U64 },
+	[IPVS_LADDR_ATTR_CONN_COUNTS]   = { .type = NLA_U32 },
+};
+
 struct nla_policy ipvs_stats_policy[IPVS_STATS_ATTR_MAX + 1] = {
-	[IPVS_STATS_ATTR_CONNS]		= { .type = NLA_U32 },
-	[IPVS_STATS_ATTR_INPKTS]	= { .type = NLA_U32 },
-	[IPVS_STATS_ATTR_OUTPKTS]	= { .type = NLA_U32 },
+	[IPVS_STATS_ATTR_CONNS]		= { .type = NLA_U64 },
+	[IPVS_STATS_ATTR_INPKTS]	= { .type = NLA_U64 },
+	[IPVS_STATS_ATTR_OUTPKTS]	= { .type = NLA_U64 },
 	[IPVS_STATS_ATTR_INBYTES]	= { .type = NLA_U64 },
 	[IPVS_STATS_ATTR_OUTBYTES]	= { .type = NLA_U64 },
 	[IPVS_STATS_ATTR_CPS]		= { .type = NLA_U32 },
diff --git a/keepalived/libipvs-2.6/libipvs.c b/keepalived/libipvs-2.6/libipvs.c
index 8ccf94d..ba5be21 100644
--- a/keepalived/libipvs-2.6/libipvs.c
+++ b/keepalived/libipvs-2.6/libipvs.c
@@ -22,11 +22,19 @@
 
 #include "libipvs.h"
 
+void ipvs_service_entry_2_user(const ipvs_service_entry_t *entry, ipvs_service_t *user);
+
 typedef struct ipvs_servicedest_s {
 	struct ip_vs_service_kern	svc;
 	struct ip_vs_dest_kern		dest;
 } ipvs_servicedest_t;
 
+typedef struct ipvs_serviceladdr_s {
+	struct ip_vs_service_kern	svc;
+	struct ip_vs_laddr_kern		laddr;
+} ipvs_serviceladdr_t;
+
+
 static int sockfd = -1;
 static void* ipvs_func = NULL;
 struct ip_vs_getinfo ipvs_info;
@@ -54,6 +62,8 @@ static int family, try_nl = 1;
 	CHECK_IPV4(s, ret);					\
 	CHECK_PE(s, ret);
 
+#define CHECK_COMPAT_LADDR(s, ret) CHECK_IPV4(s, ret)
+
 #ifdef LIBIPVS_USE_NL
 #ifndef FALLBACK_LIBNL1
 static int nlerr2syserr(int err)
@@ -320,6 +330,69 @@ out_err:
 	return -1;
 }
 
+int ipvs_update_service_by_options(ipvs_service_t *svc, unsigned int options)
+{
+	ipvs_service_entry_t *entry;
+	ipvs_service_t user;
+
+	if (!(entry = ipvs_get_service(svc->fwmark, svc->af, svc->protocol,
+				       svc->addr, svc->port))) {
+		fprintf(stderr, "%s\n", ipvs_strerror(errno));
+		exit(1);
+	}
+	ipvs_service_entry_2_user(entry, &user);
+
+	if( options & OPT_SCHEDULER ) {
+		strcpy(user.sched_name, svc->sched_name);
+	}
+
+	if( options & OPT_PERSISTENT ) {
+		user.flags  |= IP_VS_SVC_F_PERSISTENT;
+		user.timeout = svc->timeout;
+	}
+
+	if( options & OPT_NETMASK ) {
+		user.netmask = svc->netmask;
+	}
+
+	if( options & OPT_SYNPROXY ) {
+		if( svc->flags & IP_VS_CONN_F_SYNPROXY ) {
+			user.flags |= IP_VS_CONN_F_SYNPROXY;
+		} else {
+			user.flags &= ~IP_VS_CONN_F_SYNPROXY;
+		}
+	}
+
+	if( options & OPT_ONEPACKET ) {
+		user.flags |= IP_VS_SVC_F_ONEPACKET;
+	}
+
+	return ipvs_update_service(&user);
+}
+
+int ipvs_update_service_synproxy(ipvs_service_t *svc , int enable)
+{
+	ipvs_service_entry_t *entry;
+
+	if (!(entry = ipvs_get_service(svc->fwmark, svc->af, svc->protocol,
+				       svc->addr, svc->port))) {
+		fprintf(stderr, "%s\n", ipvs_strerror(errno));
+		exit(1);
+	}
+	
+	strcpy(svc->sched_name , entry->sched_name);
+	strcpy(svc->pe_name , entry->pe_name);
+	svc->flags = entry->flags;
+	svc->timeout = entry->timeout;
+	svc->netmask = entry->netmask;
+	
+	if(enable)
+		svc->flags = svc->flags | IP_VS_CONN_F_SYNPROXY;
+	else
+		svc->flags = svc->flags & (~IP_VS_CONN_F_SYNPROXY);
+	
+	return ipvs_update_service(svc);	
+}
 
 int ipvs_del_service(ipvs_service_t *svc)
 {
@@ -488,6 +561,91 @@ out_err:
 }
 
 
+#ifdef LIBIPVS_USE_NL
+static int ipvs_nl_fill_laddr_attr(struct nl_msg *msg, ipvs_laddr_t * laddr)
+{
+	struct nlattr *nl_laddr;
+
+	nl_laddr = nla_nest_start(msg, IPVS_CMD_ATTR_LADDR);
+	if (!nl_laddr)
+		return -1;
+
+	NLA_PUT(msg, IPVS_LADDR_ATTR_ADDR , sizeof(laddr->addr), &(laddr->addr));
+
+	nla_nest_end(msg, nl_laddr);
+	return 0;
+
+nla_put_failure:
+	return -1;
+}
+#endif
+
+int ipvs_add_laddr(ipvs_service_t *svc, ipvs_laddr_t * laddr)
+{
+	ipvs_serviceladdr_t svcladdr;
+	ipvs_func = ipvs_add_laddr;
+
+#ifdef LIBIPVS_USE_NL
+	if (try_nl) {
+		struct nl_msg *msg = ipvs_nl_message(IPVS_CMD_NEW_LADDR , 0);
+		if (!msg) return -1;
+		if (ipvs_nl_fill_service_attr(msg, svc))
+			goto nla_put_failure;
+		if (ipvs_nl_fill_laddr_attr(msg, laddr))
+			goto nla_put_failure;
+		return ipvs_nl_send_message(msg, ipvs_nl_noop_cb, NULL);
+
+nla_put_failure:
+		nlmsg_free(msg);
+		return -1;
+	}
+#endif
+	
+	CHECK_COMPAT_SVC(svc, -1);
+	CHECK_COMPAT_LADDR(laddr, -1);
+
+	memcpy(&svcladdr.svc, svc, sizeof(svcladdr.svc));
+	memcpy(&svcladdr.laddr, laddr, sizeof(svcladdr.laddr));
+
+	return setsockopt(sockfd, IPPROTO_IP, IP_VS_SO_SET_ADDLADDR,
+			  (char *)&svcladdr, sizeof(svcladdr));
+out_err:
+	return -1;
+}
+
+int ipvs_del_laddr(ipvs_service_t *svc, ipvs_laddr_t * laddr)
+{
+        ipvs_serviceladdr_t svcladdr;
+	ipvs_func = ipvs_del_laddr;
+
+#ifdef LIBIPVS_USE_NL
+	if (try_nl) {
+		struct nl_msg *msg = ipvs_nl_message(IPVS_CMD_DEL_LADDR , 0);
+		if (!msg) return -1;
+		if (ipvs_nl_fill_service_attr(msg, svc))
+			goto nla_put_failure;
+		if (ipvs_nl_fill_laddr_attr(msg, laddr))
+			goto nla_put_failure;
+		return ipvs_nl_send_message(msg, ipvs_nl_noop_cb, NULL);
+
+nla_put_failure:
+		nlmsg_free(msg);
+		return -1;
+	}
+#endif
+
+	CHECK_COMPAT_SVC(svc, -1);
+	CHECK_COMPAT_LADDR(laddr, -1);
+
+	memcpy(&svcladdr.svc, svc, sizeof(svcladdr.svc));
+	memcpy(&svcladdr.laddr, laddr, sizeof(svcladdr.laddr));
+
+        return setsockopt(sockfd, IPPROTO_IP, IP_VS_SO_SET_DELLADDR,
+                          (char *)&svcladdr, sizeof(svcladdr));
+out_err:
+	return -1;
+}
+
 int ipvs_set_timeout(ipvs_timeout_t *to)
 {
 	ipvs_func = ipvs_set_timeout;
@@ -591,9 +749,9 @@ static int ipvs_parse_stats(struct ip_vs_stats_user *stats, struct nlattr *nla)
 	      attrs[IPVS_STATS_ATTR_OUTBPS]))
 		return -1;
 
-	stats->conns = nla_get_u32(attrs[IPVS_STATS_ATTR_CONNS]);
-	stats->inpkts = nla_get_u32(attrs[IPVS_STATS_ATTR_INPKTS]);
-	stats->outpkts = nla_get_u32(attrs[IPVS_STATS_ATTR_OUTPKTS]);
+	stats->conns = nla_get_u64(attrs[IPVS_STATS_ATTR_CONNS]);
+	stats->inpkts = nla_get_u64(attrs[IPVS_STATS_ATTR_INPKTS]);
+	stats->outpkts = nla_get_u64(attrs[IPVS_STATS_ATTR_OUTPKTS]);
 	stats->inbytes = nla_get_u64(attrs[IPVS_STATS_ATTR_INBYTES]);
 	stats->outbytes = nla_get_u64(attrs[IPVS_STATS_ATTR_OUTBYTES]);
 	stats->cps = nla_get_u32(attrs[IPVS_STATS_ATTR_CPS]);
@@ -829,7 +987,148 @@ static int ipvs_dests_parse_cb(struct nl_msg *msg, void *arg)
 	*dp = d;
 	return 0;
 }
+
+static int ipvs_laddrs_parse_cb(struct nl_msg *msg, void *arg)
+{
+	struct nlmsghdr *nlh = nlmsg_hdr(msg);
+	struct nlattr *attrs[IPVS_CMD_ATTR_MAX + 1];
+	struct nlattr *laddr_attrs[IPVS_LADDR_ATTR_MAX + 1];
+	struct ip_vs_get_laddrs **lp = (struct ip_vs_get_laddrs **)arg;
+	struct ip_vs_get_laddrs *l = (struct ip_vs_get_laddrs *)*lp;
+	int i = l->num_laddrs;
+
+	if (genlmsg_parse(nlh, 0, attrs, IPVS_CMD_ATTR_MAX, ipvs_cmd_policy) != 0){
+		return -1;
+	}
+
+	if (!attrs[IPVS_CMD_ATTR_LADDR])
+		return -1;
+
+	if (nla_parse_nested(laddr_attrs, IPVS_LADDR_ATTR_MAX, attrs[IPVS_CMD_ATTR_LADDR], ipvs_laddr_policy)){
+		return -1;
+	}
+
+	memset(&(l->entrytable[i]), 0, sizeof(l->entrytable[i]));
+
+	if (!(laddr_attrs[IPVS_LADDR_ATTR_ADDR] &&
+		laddr_attrs[IPVS_LADDR_ATTR_PORT_CONFLICT] &&
+		laddr_attrs[IPVS_LADDR_ATTR_CONN_COUNTS])){
+		return -1;
+	}
+
+	memcpy(&(l->entrytable[i].addr), 
+		nla_data(laddr_attrs[IPVS_LADDR_ATTR_ADDR]),
+		sizeof(l->entrytable[i].addr));
+	l->entrytable[i].port_conflict = nla_get_u64(laddr_attrs[IPVS_LADDR_ATTR_PORT_CONFLICT]);
+	l->entrytable[i].conn_counts = nla_get_u32(laddr_attrs[IPVS_LADDR_ATTR_CONN_COUNTS]);
+	l->num_laddrs++;
+
+	l = realloc(l, sizeof(*l) + sizeof(ipvs_laddr_entry_t) * (l->num_laddrs + 1));
+	*lp = l;
+
+	return 0;
+}
+#endif
+
+struct ip_vs_get_laddrs *ipvs_get_laddrs(ipvs_service_entry_t *svc)
+{
+	struct ip_vs_get_laddrs 	*l;
+	struct ip_vs_get_laddrs_kern 	*lk;
+	socklen_t 			len;
+	int i;
+
+	len = sizeof(*l) + sizeof(ipvs_laddr_entry_t) * svc->num_laddrs;
+	if (!(l = malloc(len)))
+		return NULL;
+
+	ipvs_func = ipvs_get_laddrs;
+
+#ifdef LIBIPVS_USE_NL
+	if (try_nl) {
+		struct nl_msg *                 msg;
+        	struct nlattr *                 nl_service;
+		if (svc->num_laddrs == 0)
+			l = realloc(l,sizeof(*l) + sizeof(ipvs_laddr_entry_t));
+		l->fwmark = svc->fwmark;
+		l->protocol = svc->protocol;
+		l->addr = svc->addr;
+		l->port = svc->port;
+		l->num_laddrs = svc->num_laddrs;
+		l->af = svc->af;
+
+		msg = ipvs_nl_message(IPVS_CMD_GET_LADDR , NLM_F_DUMP);
+		if (!msg)
+			goto ipvs_nl_laddr_failure;
+
+		nl_service = nla_nest_start(msg, IPVS_CMD_ATTR_SERVICE);
+		if (!nl_service)
+			goto nla_put_failure;
+
+		NLA_PUT_U16(msg, IPVS_SVC_ATTR_AF, svc->af);
+
+		if (svc->fwmark) {
+			NLA_PUT_U32(msg, IPVS_SVC_ATTR_FWMARK, svc->fwmark);
+		} else {
+			NLA_PUT_U16(msg, IPVS_SVC_ATTR_PROTOCOL, svc->protocol);
+			NLA_PUT(msg, IPVS_SVC_ATTR_ADDR, sizeof(svc->addr),
+				&svc->addr);
+			NLA_PUT_U16(msg, IPVS_SVC_ATTR_PORT, svc->port);
+		}
+
+		nla_nest_end(msg, nl_service);
+		if (ipvs_nl_send_message(msg, ipvs_laddrs_parse_cb, &l))
+			goto ipvs_nl_laddr_failure;
+
+		return l;
+
+nla_put_failure:
+		nlmsg_free(msg);
+ipvs_nl_laddr_failure:
+		free(l);
+		return NULL;
+	}
 #endif
+	if (svc->af != AF_INET) {
+	  errno = EAFNOSUPPORT;
+	  free(l);
+	  return NULL;
+	}
+
+	len = sizeof(*lk) + sizeof(struct ip_vs_laddr_entry_kern) * svc->num_laddrs;
+	if (!(lk = malloc(len)))
+		return NULL;
+
+	lk->fwmark = svc->fwmark;
+	lk->protocol = svc->protocol;
+	lk->addr = svc->addr.ip;
+	lk->port = svc->port;
+	lk->num_laddrs = svc->num_laddrs;
+
+	if (getsockopt(sockfd, IPPROTO_IP,
+		       IP_VS_SO_GET_LADDRS, lk, &len) < 0) {
+		free(l);
+		free(lk);
+		return NULL;
+	}
+	memcpy(l, lk, sizeof(struct ip_vs_get_laddrs_kern));
+	l->af = AF_INET;
+	l->addr.ip = l->__addr_v4;
+	for (i = 0; i < lk->num_laddrs; i++) {
+		memcpy(&l->entrytable[i], &lk->entrytable[i],
+		       sizeof(struct ip_vs_laddr_entry_kern));
+		l->entrytable[i].af = AF_INET;
+		l->entrytable[i].addr.ip = l->entrytable[i].__addr_v4;
+	}
+	free(lk);
+	return l;
+}
+
+
+void ipvs_free_lddrs(struct ip_vs_get_laddrs* p)
+{
+	free(p);
+}
+
 
 struct ip_vs_get_dests *ipvs_get_dests(ipvs_service_entry_t *svc)
 {
@@ -1015,6 +1314,7 @@ ipvs_get_service_err2:
 	svc->port = port;
 
 	CHECK_COMPAT_SVC(svc, NULL);
+	CHECK_PE(svc, NULL);
 	if (getsockopt(sockfd, IPPROTO_IP, IP_VS_SO_GET_SERVICE,
 		       (char *)svc, &len)) {
 		free(svc);
@@ -1183,6 +1483,11 @@ const char *ipvs_strerror(int err)
 		{ ipvs_get_services, ESRCH, "No such service" },
 		{ ipvs_get_dests, ESRCH, "No such service" },
 		{ ipvs_get_service, ESRCH, "No such service" },
+		{ ipvs_add_laddr, ESRCH, "Service not defined" },
+		{ ipvs_add_laddr, EEXIST, "Local address already exists" },
+		{ ipvs_del_laddr, ESRCH, "Service not defined" },
+		{ ipvs_del_laddr, ENOENT, "No such Local address" },
+		{ ipvs_get_laddrs, ESRCH, "Service not defined" },
 		{ 0, EPERM, "Permission denied (you must be root)" },
 		{ 0, EINVAL, "Invalid operation.  Possibly wrong module version, address not unicast, ..." },
 		{ 0, ENOPROTOOPT, "Protocol not available" },
@@ -1200,3 +1505,20 @@ const char *ipvs_strerror(int err)
 
 	return strerror(err);
 }
+
+
+void ipvs_service_entry_2_user(const ipvs_service_entry_t *entry, ipvs_service_t *user)
+{
+	user->protocol  = entry->protocol;
+	user->__addr_v4 = entry->__addr_v4;
+	user->port      = entry->port;
+	user->fwmark    = entry->fwmark;
+	strcpy(user->sched_name, entry->sched_name);
+	user->flags     = entry->flags;
+	user->timeout   = entry->timeout;
+	user->netmask   = entry->netmask;
+	user->af        = entry->af;
+	user->addr      = entry->addr;
+	strcpy(user->pe_name, entry->pe_name);
+}
+
diff --git a/keepalived/libipvs-2.6/libipvs.h b/keepalived/libipvs-2.6/libipvs.h
index 8eeea13..956e45e 100644
--- a/keepalived/libipvs-2.6/libipvs.h
+++ b/keepalived/libipvs-2.6/libipvs.h
@@ -12,6 +12,33 @@
 
 #include "ip_vs.h"
 
+#define OPT_NONE		0x000000
+#define OPT_NUMERIC		0x000001
+#define OPT_CONNECTION		0x000002
+#define OPT_SERVICE		0x000004
+#define OPT_SCHEDULER		0x000008
+#define OPT_PERSISTENT		0x000010
+#define OPT_NETMASK		0x000020
+#define OPT_SERVER		0x000040
+#define OPT_FORWARD		0x000080
+#define OPT_WEIGHT		0x000100
+#define OPT_UTHRESHOLD		0x000200
+#define OPT_LTHRESHOLD		0x000400
+#define OPT_MCAST		0x000800
+#define OPT_TIMEOUT		0x001000
+#define OPT_DAEMON		0x002000
+#define OPT_STATS		0x004000
+#define OPT_RATE		0x008000
+#define OPT_THRESHOLDS		0x010000
+#define OPT_PERSISTENTCONN	0x020000
+#define OPT_NOSORT		0x040000
+#define OPT_SYNCID		0x080000
+#define OPT_EXACT		0x100000
+#define OPT_ONEPACKET		0x200000
+#define OPT_PERSISTENCE_ENGINE  0x400000
+#define OPT_LOCAL_ADDRESS	0x800000
+#define OPT_SYNPROXY		0x1000000
+#define NUMBER_OF_OPT		25
 
 #define MINIMUM_IPVS_VERSION_MAJOR      1
 #define MINIMUM_IPVS_VERSION_MINOR      1
@@ -36,10 +63,12 @@
 
 typedef struct ip_vs_service_user	ipvs_service_t;
 typedef struct ip_vs_dest_user		ipvs_dest_t;
+typedef struct ip_vs_laddr_user 	ipvs_laddr_t;
 typedef struct ip_vs_timeout_user	ipvs_timeout_t;
 typedef struct ip_vs_daemon_user	ipvs_daemon_t;
 typedef struct ip_vs_service_entry	ipvs_service_entry_t;
 typedef struct ip_vs_dest_entry		ipvs_dest_entry_t;
+typedef struct ip_vs_laddr_entry	ipvs_laddr_entry_t;
 
 
 /* ipvs info variable */
@@ -63,6 +92,12 @@ extern int ipvs_add_service(ipvs_service_t *svc);
 /* update a virtual service with new options */
 extern int ipvs_update_service(ipvs_service_t *svc);
 
+/* update a virtual service based on option */
+extern int ipvs_update_service_by_options(ipvs_service_t *svc, unsigned int options);
+
+/* config the service's synproxy switch */
+extern int ipvs_update_service_synproxy(ipvs_service_t *svc , int enable);
+
 /* delete a virtual service */
 extern int ipvs_del_service(ipvs_service_t *svc);
 
@@ -78,6 +113,10 @@ extern int ipvs_update_dest(ipvs_service_t *svc, ipvs_dest_t *dest);
 /* remove a destination server from a service */
 extern int ipvs_del_dest(ipvs_service_t *svc, ipvs_dest_t *dest);
 
+extern int ipvs_add_laddr(ipvs_service_t *svc, ipvs_laddr_t * laddr);
+extern int ipvs_del_laddr(ipvs_service_t *svc, ipvs_laddr_t * laddr);
+extern struct ip_vs_get_laddrs *ipvs_get_laddrs(ipvs_service_entry_t *svc);
+
 /* set timeout */
 extern int ipvs_set_timeout(ipvs_timeout_t *to);
 
-- 
2.12.0.windows.1

